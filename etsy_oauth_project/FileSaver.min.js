/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2018-12-01
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

var saveAs = saveAs || (function(view) {
    "use strict";
    // IE <10 is explicitly unsupported
    if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
    }
    var doc = view.document
        // only get URL when necessary in case Blob.js hasn't overridden it yet
        ,
        get_URL = function() {
            return view.URL || view.webkitURL || view;
        },
        save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
        can_use_save_link = "download" in save_link,
        click = function(node) {
            var event = new MouseEvent("click");
            node.dispatchEvent(event);
        },
        is_safari = /constructor/i.test(view.HTMLElement) || view.safari,
        is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent),
        throw_outside = function(ex) {
            (view.setImmediate || view.setTimeout)(function() {
                throw ex;
            }, 0);
        },
        force_saveable_type = "application/octet-stream" || "application\/pdf" || "image/png" || "image/jpeg",
        // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
        arbitrary_revoke_timeout = 1000 * 40, // in ms
        revoke = function(file) {
            var revoker = function() {
                if (typeof file === "string") {
                    // file is an object URL
                    get_URL().revokeObjectURL(file);
                } else {
                    // file is a File
                    file.remove();
                }
            };
            setTimeout(revoker, arbitrary_revoke_timeout);
        },
        dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver["on" + event_types[i]];
                if (typeof listener === "function") {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        },
        auto_bom = function(blob) {
            // prepend BOM for UTF-8 XML and text/* types (including HTML)
            // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
            if (/(?:^text\/(?:plain|csv|html)|application\/xml|\bxml\b)/.test(blob.type)) {
                return new Blob(["\ufeff", blob], {
                    type: blob.type
                });
            }
            return blob;
        },
        FileSaver = function(blob, name, no_auto_bom) {
            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            // First try a.download, then web filesystem, then object URLs
            var filesaver = this,
                type = blob.type,
                blob_changed = false,
                object_url, target_view, dispatch_all = function() {
                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                },
                // on any filesys errors revert to saving with object URLs
                fs_error = function() {
                    if ((is_chrome_ios || (object_url && typeof FileReader === "undefined")) && view.HTMLInputElement && input instanceof HTMLInputElement && input.form) {
                        var form = input.form;
                        if (form.getAttribute("download") !== null) {
                            form.removeAttribute("download");
                        }
                    }
                    if (is_safari) {
                        var reader = new FileReader();
                        reader.onloadend = function() {
                            var base64Data = reader.result.split(",")[1];
                            view.location.href = "data:attachment/file" + base64Data;
                            filesaver.readyState = filesaver.DONE;
                            dispatch_all();
                        };
                        reader.readAsDataURL(blob);
                    } else {
                        filesaver.readyState = filesaver.DONE;
                        dispatch_all();
                    }
                    revoke(object_url);
                },
                abortable = function(func) {
                    return function() {
                        if (filesaver.readyState !== filesaver.DONE) {
                            return func.apply(this, arguments);
                        }
                    };
                },
                create_if_not_found = {
                    create: true,
                    exclusive: false
                },
                slice;
            filesaver.readyState = filesaver.INIT;
            if (!name) {
                name = "download";
            }
            if (can_use_save_link) {
                object_url = get_URL().createObjectURL(blob);
                setTimeout(function() {
                    save_link.href = object_url;
                    save_link.download = name;
                    click(save_link);
                    dispatch_all();
                    revoke(object_url);
                    filesaver.readyState = filesaver.DONE;
                });
                return;
            }
            // Object and web filesystem URLs have a problem saving in Google Chrome when
            // viewed in a tab, so I force save with application/octet-stream
            // http://code.google.com/p/chromium/issues/detail?id=91158
            // Update: Google errantly closed 91158, I submitted it again:
            // https://code.google.com/p/chromium/issues/detail?id=389642
            if (view.chrome && type && type !== force_saveable_type) {
                slice = blob.slice || blob.webkitSlice;
                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                blob_changed = true;
            }
            // Since I can't be sure that the guessed media type will trigger a download
            // in WebKit, I append .download to the filename.
            // https://bugs.webkit.org/show_bug.cgi?id=65440
            if (is_chrome_ios) {
                var reader = new FileReader();
                reader.onloadend = function() {
                    var base64Data = reader.result.split(",")[1];
                    view.location.href = "data:attachment/file" + base64Data;
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                    revoke(object_url);
                };
                reader.readAsDataURL(blob);
                return;
            }
            if (/^data:/.test(type)) {
                // Data URLs can't be saved directly
                if (!object_url) {
                    object_url = get_URL().createObjectURL(blob);
                }
                if (type.indexOf(";base64") !== -1) {
                    view.location.href = object_url;
                } else {
                    view.location.href = object_url.replace(/^[^#]+/, "") + "#" + name;
                }
                filesaver.readyState = filesaver.DONE;
                dispatch_all();
                revoke(object_url);
                return;
            }
            // Object and web filesystem URLs have a problem saving in some browsers
            // when viewed in a tab, so I force save with application/octet-stream
            // http://code.google.com/p/chromium/issues/detail?id=91158
            // Update: Google errantly closed 91158, I submitted it again:
            // https://code.google.com/p/chromium/issues/detail?id=389642
            if (view.chrome && type && type !== force_saveable_type) {
                slice = blob.slice || blob.webkitSlice;
                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                blob_changed = true;
            }
            // for non-Blob supporting browsers like IE
            if (!object_url) {
                object_url = get_URL().createObjectURL(blob);
            }
            if (typeof FileReader !== "undefined") {
                // Safari doesn't allow downloading of blob urls
                var reader = new FileReader();
                reader.onloadend = function() {
                    var base64Data = reader.result.split(",")[1];
                    view.location.href = "data:attachment/file" + base64Data;
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                    revoke(object_url);
                };
                reader.readAsDataURL(blob);
                return;
            }
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    var status = xhr.status === 0,
                        success = status || (xhr.status >= 200 && xhr.status < 300),
                        blob_url;
                    if (success) {
                        blob_url = xhr.response;
                        if (blob_url.length > 5000000) {
                            // Safari can't download... big files?
                            dispatch(filesaver, "error");
                            filesaver.readyState = filesaver.DONE;
                            return;
                        }
                        if (typeof safari !== "undefined") {
                            // handle blob URLs in Safari
                            view.location.href = blob_url;
                        } else {
                            var fr = new FileReader();
                            fr.onloadend = function() {
                                var data = fr.result;
                                if (is_safari) {
                                    // (data) + (object URL of data)
                                    var view = new Uint8Array(data);
                                    var blob = new Blob([view, blob], {
                                        type: type
                                    });
                                    object_url = get_URL().createObjectURL(blob);
                                }
                                view.location.href = object_url;
                                filesaver.readyState = filesaver.DONE;
                                dispatch_all();
                                revoke(object_url);
                            };
                            fr.readAsArrayBuffer(blob);
                        }
                    } else {
                        // download failed
                        if (!status) {
                            dispatch(filesaver, "error");
                        }
                        filesaver.readyState = filesaver.DONE;
                        dispatch_all();
                        revoke(object_url);
                    }
                }
            };
            var force = blob.type === force_saveable_type;
            xhr.open("GET", force ? object_url : object_url, true);
            if ("responseType" in xhr) {
                xhr.responseType = "blob";
            }
            if (force) {
                xhr.setRequestHeader("If-Modified-Since", "Mon, 26 Jul 1997 05:00:00 GMT");
            }
            if (force && type !== force_saveable_type) {
                // IE doesn't know how to get a blob's contentType
                var xhr = new XMLHttpRequest();
                xhr.open("HEAD", object_url, true);
                xhr.onreadystatechange = function() {
                    if (xhr.readyState == 4) {
                        type = xhr.getResponseHeader("Content-Type") || force_saveable_type;
                        xhr = new XMLHttpRequest();
                        xhr.open("GET", object_url, true);
                        if ("responseType" in xhr) {
                            xhr.responseType = "blob";
                        }
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState == 4) {
                                blob = xhr.response;
                                blob_changed = true;
                                filesaver.readyState = filesaver.DONE;
                                dispatch_all();
                                revoke(object_url);
                            }
                        };
                        xhr.send();
                    }
                };
                xhr.send();
            } else {
                xhr.send();
            }
        },
        FS_proto = FileSaver.prototype,
        saveAs = function(blob, name, no_auto_bom) {
            return new FileSaver(blob, name, no_auto_bom);
        };
    // IE 10+ (native saveAs)
    if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
        return function(blob, name, no_auto_bom) {
            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            return navigator.msSaveOrOpenBlob(blob, name || "download");
        };
    }
    FS_proto.abort = function() {};
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;
    FS_proto.error =
        FS_proto.onwritestart =
        FS_proto.onprogress =
        FS_proto.onwrite =
        FS_proto.onabort =
        FS_proto.onerror =
        FS_proto.onwriteend =
        null;
    return saveAs;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));